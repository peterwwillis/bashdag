#!/usr/bin/env bash
set -eu
[ "${DEBUG:-0}" = "1" ] && set -x

# ## Objects
# - `dag`: *associative array*. Mapping of dag name to dag index number.
# - `dag_r`: *associative array*. Reverse-mapping of index number to dag name
# - `dag_nv`: *associative array*. Keys are "name:dependency", values are '1' if mapping already set in `dag`.
# - `_dag_deps_INDEX`: *array*. The array of dependencies for a dag INDEX. The values are more INDEXes.
# - `_dag_r_attr_NAME_INDEX`: *array*. A dynamically-created array specific to an attribute NAME and the INDEX of a dag entry.
# 
# By design, the internal functions give each element of the DAG an index number
# and refer to them by their indexes. This enables making arrays dynamically that
# refer to specific elements of the DAG without running into naming conflicts 
# (array names have a limited character set).
# 
declare -A dag dag_r dag_nv
declare -a attrs=('started' 'done' 'program') # The NAMEs in _dag_r_attr_NAME_INDEX
declare -i _dag_c=0 # Global INDEX counter (will this roll over on really big DAGs?)

_err () { echo "$0: Error: $*" 1>&2 ; exit 1 ; }

_add_dagname () {
    local name="$1" n
    if [ -z "${dag["$name"]+unset}" ] ; then
        dag["$name"]=$_dag_c
        # shellcheck disable=SC2034
        dag_r[$_dag_c]="$name"
        #echo "    dag $_dag_c=$name"
        eval "declare -a _dag_deps_${_dag_c}" # declare -a _dag_deps_0
        for n in "${attrs[@]}" ; do
            eval "declare -a _dag_r_attr_${n}_${_dag_c}"
        done
        _dag_c=$((_dag_c+1))
    fi
}

_add_dagvalue () {
    local arr name="$1" value="$2"
    if [ -z "${dag_nv["$name:$value"]+unset}" ] ; then
        declare -n arr="_dag_deps_${dag["$name"]}"
        dag_nv["$name:$value"]=1
        #echo "      Appending to array _dag_deps_${dag["$name"]}"
        arr+=("${dag["$value"]}")
    fi
}

# Usage: dagdep NAME DEPENDENCY
# Add a record NAME to the dag as depending on DEPENDENCY.
dagdep () {
    local name="$1" dep="$2"
    #echo "  name '$name' dependency '$dep'"
    _add_dagname "$name"
    _add_dagname "$dep"
    _add_dagvalue "$name" "$dep"
}

# Usage: dag_r_attr ATTRIBUTE INDEX [VALUE ..]
# Retrieve and set attributes in attribute-specific arrays.
#   Pass an attribute name and a a dag index, and optional values.
#   If optional values are passed, sets an array to the values and returns 0.
#   If there is no value set, returns 1.
#   If there is a value set, prints the value and returns 0.
dag_r_attr () {
    local arr arrname="$1" dag_i="$2"; shift 2
    declare -n arr="_dag_r_attr_${arrname}_${dag_i}"
    if [ $# -lt 1 ] ; then
        if [ -z "${arr+unset}" ] ; then
            return 1
        fi
        printf "%s\n" "${arr[*]}"
    else
        arr=("$@")
    fi
    return 0
}

# Usage: dagrun NAME
# Recursively run the dag starting at NAME.
dagrun () {
    local arr name="$1" dag_i i
    if [ -z "${dag["$name"]+unset}" ] ; then
        _err "Dag '$name' does not exist"
    fi
    dag_i="${dag["$name"]}"
    declare -n arr="_dag_deps_$dag_i"
    echo "Running dag index $dag_i: $name" 1>&2
    if dag_r_attr "done" "$dag_i" >/dev/null ; then
        echo "  Dag $name already done" 1>&2
        return 0
    fi
    if ! dag_r_attr "started" "$dag_i" >/dev/null ; then
        dag_r_attr "started" "$dag_i" 1
    else
        echo "  $name already started" 1>&2
        return 0
    fi
    for i in "${arr[@]}" ; do
        if ! dag_r_attr "done" "$i" >/dev/null ; then
            if ! dag_r_attr "started" "$i" >/dev/null ; then
                dagrun "${dag_r["$i"]}"
            fi
        fi
    done
    if dag_r_attr "program" "$dag_i" >/dev/null ; then
        declare -n arr="_dag_r_attr_program_${dag_i}"
        echo "    Running program for $name: '${arr[*]}'" 1>&2
        # shellcheck disable=SC2068
        bash -c "${arr[@]}"
    fi
    echo "  Finished dag run '$name'" 1>&2
    dag_r_attr "done" "$dag_i" 1
}

# Define a program that should be executed for a given dag.
# Usage: dagprogram NAME CMD [..]
dagprogram () {
    local arr name="$1" dag_i="${dag["$1"]}" ; shift 1
    dag_r_attr "program" "$dag_i" "$@"
    #echo "Set $name program to '$*'"
}

# Show the dag's dependencies.
showdag () {
    local arr arr2 name i d depslist program
    "_showdag_$outtype" "dag"
    for i in "${!dag_r[@]}" ; do
        name="${dag_r[$i]}"
        # shellcheck disable=SC2178
        declare -n arr="_dag_deps_${dag["$name"]}"
        depslist=""
        for d in "${arr[@]}" ; do
            depslist="${depslist:+${depslist}, }${dag_r[$d]}"
        done
        program=""
        if dag_r_attr "program" "$i" >/dev/null ; then
            declare -n arr2="_dag_r_attr_program_${i}"
            program="${arr2[*]}"
        fi
        "_showdag_$outtype" "$name" "$i" "$depslist" "$program"
    done
    "_showdag_$outtype"
}
_showdag_text () {
    [ $# -gt 1 ] || return 0
    local name="$1" i="$2" depslist="$3" program="$4"
    printf "%s$newline" "#  $name ($i):"
    [ -n "${depslist:-}" ] && printf "%s$newline" "#    dependencies: $depslist"
    [ -n "${program:-}" ] && printf "%s$newline" "     $program"
}
_showdag_yaml () {
    local name indent=0 i depslist program arr2 spaces
    if [ $# -eq 0 ] ; then
        return 0
    elif [ $# -eq 1 ] ; then
        name="$1"; shift
        printf "%${indent}s$newline" "--- # dag"
        printf "%${indent}s$newline" "$name:"
        return 0
    elif [ $# -gt 1 ] ; then
        name="$1" i="$2" depslist="$3" program="$4"; shift 4
        indent="4"
    fi
    printf "%${indent}s$newline" "- $name:"
    printf "%${indent}s$newline" "    index: $i"
    if [ -n "${depslist:-}" ] ; then
        printf "%${indent}s$newline" "    dependencies: [ $depslist ]"
    fi
    if [ -n "${program:-}" ] ; then
        printf "%${indent}s$newline" "    program: |-"
        declare -n arr2="_dag_r_attr_program_${i}"
        spaces="$(printf "%${indent}s" " ")"
        printf "%s\n" "${arr2[@]}" | sed -e "s/^/$spaces      /g"
    fi
}
_showdag_json () {
    local name i depslist program arr2 spaces
    if [ $# -eq 1 ] ; then
        name="$1"; shift
        printf "%s$newline" "{"
        printf "%s$newline" "\"$name\": ["
        return 0
    elif [ $# -eq 0 ] ; then
        printf "%s$newline" "    ]"
        printf "%s$newline" "}"
        unset _showdag_json_firstline
        return 0
    elif [ $# -gt 1 ] ; then
        name="$1" i="$2" depslist="$3" program="$4"; shift 4
        depslist="$(printf "%s\n" "$depslist" | sed -E 's/(,?\s+?)([^,]+)/\1"\2"/g')"
    fi
    printf "%s" "      ${_showdag_json_firstline:+,}{ \"$name\": {"
    printf "%s" " \"index\": $i"
    if [ -n "${depslist:-}" ] ; then
        printf "%s" ", \"dependencies\": [ $depslist ]"
    fi
    if [ -n "${program:-}" ] ; then
        declare -n arr2="_dag_r_attr_program_${i}"
        printf "%s" ", \"program\": \"$(_json_fmt_str "${arr2[@]}")\""
    fi
    printf "%s$newline" " } }"
    _showdag_json_firstline=1
}
_json_fmt_str () {
    local str="$1"
    str=${str//\\/\\\\} # \ 
    str=${str//\//\\\/} # / 
    str=${str//\'/\\\'} # ' (not strictly needed ?)
    str=${str//\"/\\\"} # " 
    str=${str//	/\\t} # \t (tab)
    str=${str//
/\\\n} # \n (newline)
    str=${str//^M/\\\r} # \r (carriage return)
    str=${str//^L/\\\f} # \f (form feed)
    str=${str//^H/\\\b} # \b (backspace)
    printf "%s\n" "$str"
}

_load_conf () {
    for f in "$@" ; do
        eval "$(cat "$f")"
    done
}

_usage () {
    cat <<EOUSAGE
Usage: $0 [OPTIONS] [DAG ..]

Create a Directed Acyclic Graph and do stuff with it (with Bash).

Config file is (currently) just a Bash script that gets eval'd into the main
script. You can use built-in commands to create and modify the DAG, create the
DAG programmatically using Bash scripting, and access all the internals of the
script.

Options:
    -f FILE         Load dag configuration from FILE
    -s              Show parsed dag
    -0              Separate each output record by null byte
    -o TYPE         Set '-s' output as TYPE (text, yaml, json)
    -r              Execute the programs specified for each dag item starting at DAG
    -h              This screen
EOUSAGE
    exit 1
}

declare -a dagconfs=()
newline="\n"
outtype="text"
SHOWDAG=${SHOWDAG:-0} RUNDAG=${RUNDAG:-0}
while getopts "f:sr0o:h" args ; do
    case "$args" in
        f)      dagconfs+=("$OPTARG") ;;
        s)      SHOWDAG=1 ;;
        r)      RUNDAG=1 ;;
        0)      newline="\0" ;;
        o)      outtype="$OPTARG" ;;
        h)      _usage ;;
        *)      _err "unknown option '$args'" ;;
    esac
done
shift $((OPTIND-1))


_load_conf "${dagconfs[@]}"

if [ $SHOWDAG -eq 1 ] ; then
    [ "${#dagconfs[*]}" -lt 1 ] && _usage
    showdag
elif [ $RUNDAG -eq 1 ] ; then
    [ $# -lt 1 ] && _usage
    for i in "$@" ; do
        dagrun "$i"
    done
else
    _usage
fi
